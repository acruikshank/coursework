<html>
<head>
  <title>Paralax 4</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
  body {
    background: #000;
  }

  .parallax {
    perspective: 1px;
    height: 100vh;
    overflow-x: hidden;
    overflow-y: auto;
  }
  .parallax__layer {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
  .parallax__layer--base {
    padding: 60vh 0;
    transform: translateZ(0);
  }

  .parallax__layer--base2 {
    padding: 150vh 0;
    transform: translateZ(0);
  }
  .parallax__layer--back img {
    width: 100vw;
  }

  .parallax__layer--back {
    padding: 0 0 100vh;
    transform: translateZ(-.25px) scale(1.25);
    height: 50vh;
  }

  img.logo {
    width: 10vw;
    margin: 20vh auto;
    z-index: 1;
    position: relative;
  }

  h1 {
    display: inline-block;
    width: 100%;
    margin: 10vh 0;
    z-index: 1;
    position: relative;
  }

  .parallax__inner {
    background: rgb(38,38,38);
    position: relative;
    color: white;
    line-height: 40vh;
    font-size: 10vh;
    text-align: center;
    font-family: andale mono;
  }

  canvas {
    background: #000;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
  }

  * {
    margin: 0;
    padding: 0;
  }
  </style>
</head>
<body id="c-fab">


<script>
function createProgram(gl, vertex, fragment) {
  var shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, getShader(gl, vertex, gl.VERTEX_SHADER));
  gl.attachShader(shaderProgram, getShader(gl, fragment, gl.FRAGMENT_SHADER));
  gl.linkProgram(shaderProgram);
  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    throw new Error("Unable to link " + vertex + " and " + fragment);
  }
  return shaderProgram;
}

function getShader(gl, source, type) {
  var shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("An error occurred compiling the shaders: " + gl.getShaderInfoLog(shader));
    throw new Error("GL Compilation Error");
  }
  return shader;
}

var FRAGMENT = "precision mediump float;\n\
  uniform float resolution;\n\
  void main(void) {if ((gl_PointCoord.s > .12 && gl_PointCoord.s < .88)\n\
    && (gl_PointCoord.t > .12 && gl_PointCoord.t < .88)) discard;\n\
  gl_FragColor = vec4(0.3, 0.34, 0.35, 0.25*resolution); }";

var VERTEX = "precision mediump float;\n\
attribute vec2 vertexPosition;\n\
uniform float width;\n\
uniform float height;\n\
uniform float resolution;\n\
uniform float separation;\n\
uniform float scrollOffset;\n\
uniform float noiseStrength;\n\
uniform float scrollRate;\n\
uniform float time;\n\
uniform vec3 mouse;\n\
uniform float interactionStrength;\n\
uniform float interactionDistance;\n\
vec3 mod289(vec3 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\n\
vec4 mod289(vec4 x) {return x - floor(x * (1.0 / 289.0)) * 289.0;}\n\
vec4 permute(vec4 x) {return mod289(((x*34.0)+1.0)*x);}\n\
vec4 taylorInvSqrt(vec4 r) {return 1.79284291400159 - 0.85373472095314 * r;}\n\
float snoise(vec3 v) {\n\
  const vec2  C = vec2(1.0/6.0, 1.0/3.0);\n\
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\
  vec3 i  = floor(v + dot(v, C.yyy) );\n\
  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\
  vec3 g = step(x0.yzx, x0.xyz);\n\
  vec3 l = 1.0 - g;\n\
  vec3 i1 = min( g.xyz, l.zxy );\n\
  vec3 i2 = max( g.xyz, l.zxy );\n\
  vec3 x1 = x0 - i1 + C.xxx;\n\
  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n\
  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\
  i = mod289(i);\n\
  vec4 p = permute(permute(permute(\n\
             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n\
           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n\
           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\
  float n_ = 0.142857142857; // 1.0/7.0\n\
  vec3  ns = n_ * D.wyz - D.xzx;\n\
  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\
  vec4 x_ = floor(j * ns.z);\n\
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\
  vec4 x = x_ *ns.x + ns.yyyy;\n\
  vec4 y = y_ *ns.x + ns.yyyy;\n\
  vec4 h = 1.0 - abs(x) - abs(y);\n\
  vec4 b0 = vec4( x.xy, y.xy );\n\
  vec4 b1 = vec4( x.zw, y.zw );\n\
  vec4 s0 = floor(b0)*2.0 + 1.0;\n\
  vec4 s1 = floor(b1)*2.0 + 1.0;\n\
  vec4 sh = -step(h, vec4(0.0));\n\
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n\
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\
  vec3 p0 = vec3(a0.xy,h.x);\n\
  vec3 p1 = vec3(a0.zw,h.y);\n\
  vec3 p2 = vec3(a1.xy,h.z);\n\
  vec3 p3 = vec3(a1.zw,h.w);\n\
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n\
  p0 *= norm.x;\n\
  p1 *= norm.y;\n\
  p2 *= norm.z;\n\
  p3 *= norm.w;\n\
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n\
  m = m * m;\n\
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n\
                                dot(p2,x2), dot(p3,x3) ) );\n\
}\n\
void main(void) {\n\
  float nOffset = scrollRate*time + scrollOffset;\n\
  vec2 screenPosition = vec2(vertexPosition.x * separation - 1.1,\n\
                             vertexPosition.y * separation - height*1.2/width);\n\
  vec2 pos = vec2(screenPosition.x, screenPosition.y + mod(nOffset,separation));\n\
  vec3 nPos = vec3(screenPosition.x, screenPosition.y - separation*floor(nOffset/separation),.005*time);\n\
  float mouseDistance = distance(pos, mouse.xy);\n\
  float interaction = max(0.0, 1.0 - interactionStrength * mouse.z * exp(-interactionDistance*mouseDistance*mouseDistance));\n\
  vec2 noise = vec2(interaction*snoise(vec3(.0006*width,0.0003*width,1.8)*nPos));\n\
  gl_Position =  vec4(pos.x, width*pos.y/height, 0.0, 1.0)\n\
    + vec4(noiseStrength * noise, 1.0, 0.0);\n\
  gl_PointSize = resolution * 13.0 * pow(max(noise.x,0.0),.2);\n\
}";

function Background(offsetParent, style, config) {
  config = config || {}
  var canvas, gl, pointBuffer;
  var canvasOffset = 0;
  var coordAttribute, resolutionAttribute, widthAttribute, heightAttribute, separationAttribute;
  var timeAttribute, scrollOffsetAttribute, mouseAttribute, noiseStrengthAttribute;
  var interactionStrengthAttribute, interactionDistanceAttribute, scrollRateAttribute;
  var onscreenShader;
  var theta = 0;
  var dTheta = 0.02;
  var PIXELS_PER_SQUARE = 11.25
  var SEPARATION
  var BLEED = 1.2
  var INTERACTION_STRENGTH = config.interactionStrength || 1.75
  var INTERACTION_DISTANCE = config.interactionDistance || 20.0
  var NOISE_STRENGTH = config.noiseStrength || .25
  var SCROLL_RATE = config.scrollRate || 0.01
  var pixelRatio = window.devicePixelRatio || 1;
  var mousePosition = {x:0, y:0, w:0, iw: 0};
  var VERTICAL_SQUARES
  var HORIZONTAL_SQUARES
  var lastSize = {width: 0, height: 0}
  var resized = true;
  var active = true;

  (function init() {
    canvas = createCanvas(offsetParent)

    gl = canvas.getContext("experimental-webgl");
    if (gl) {
      onscreenShader = createProgram(gl, VERTEX, FRAGMENT);

      coordAttribute = gl.getAttribLocation(onscreenShader, "vertexPosition")
      resolutionAttribute = gl.getUniformLocation(onscreenShader, "resolution")
      widthAttribute = gl.getUniformLocation(onscreenShader, "width")
      heightAttribute = gl.getUniformLocation(onscreenShader, "height")
      separationAttribute = gl.getUniformLocation(onscreenShader, "separation")
      timeAttribute = gl.getUniformLocation(onscreenShader, "time")
      scrollOffsetAttribute = gl.getUniformLocation(onscreenShader, "scrollOffset")
      mouseAttribute = gl.getUniformLocation(onscreenShader, "mouse")
      noiseStrengthAttribute = gl.getUniformLocation(onscreenShader, "noiseStrength")
      interactionStrengthAttribute = gl.getUniformLocation(onscreenShader, "interactionStrength")
      interactionDistanceAttribute = gl.getUniformLocation(onscreenShader, "interactionDistance")
      scrollRateAttribute = gl.getUniformLocation(onscreenShader, "scrollRate")

      gl.enableVertexAttribArray(coordAttribute);

      render();
    }
  })()

  function createCanvas(container) {
    var canvas = document.createElement('canvas')
    canvas.setAttribute('style',style)
    canvas.id = parent.id + '_canvas'
    container.style.position = 'relative'
    container.insertBefore(canvas, container.firstChild)
    return canvas
  }

  function createGeometry() {
    canvas.width = canvas.offsetWidth * pixelRatio;
    canvas.height = canvas.offsetHeight * pixelRatio;
    canvasOffset = 0;
    for (var ancestor=offsetParent; ancestor && ancestor != document.body; ancestor = ancestor.offsetParent)
      canvasOffset += ancestor.offsetTop;
    theta -= -200 * canvasOffset * pixelRatio / canvas.width;
    SEPARATION = .015 * 1440 * pixelRatio / canvas.width
    if (gl) {
      VERTICAL_SQUARES = Math.floor((canvas.height*BLEED) / PIXELS_PER_SQUARE)
      HORIZONTAL_SQUARES = Math.floor((canvas.width*BLEED) / PIXELS_PER_SQUARE)
      for (var j=0,state=[]; j<VERTICAL_SQUARES; j++) {
        for (var i=0; i<HORIZONTAL_SQUARES; i++) {
          state.push(i, j)
        }
      }

      pointBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(state), gl.STATIC_DRAW);
    }
  }

  function render() {
    if (resized) {
      createGeometry()
      resized = false;
    }

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.disable(gl.DEPTH_TEST);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
    gl.enable(gl.BLEND);

    gl.useProgram(onscreenShader);

    var yFactor = canvas.width / canvas.height;
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    gl.uniform1f( resolutionAttribute, pixelRatio);
    gl.uniform1f( widthAttribute, canvas.width);
    gl.uniform1f( heightAttribute, canvas.height);
    gl.uniform1f( separationAttribute, SEPARATION);
    gl.uniform1f( interactionStrengthAttribute, INTERACTION_STRENGTH);
    gl.uniform1f( interactionDistanceAttribute, INTERACTION_DISTANCE);
    gl.uniform1f( noiseStrengthAttribute, NOISE_STRENGTH);
    gl.uniform1f( scrollRateAttribute, SCROLL_RATE);
    gl.uniform1f( timeAttribute, theta);
    gl.uniform1f( scrollOffsetAttribute, -.5*scrollTop / canvas.height);
    gl.uniform3f( mouseAttribute,
      2 * mousePosition.x * pixelRatio / canvas.width - 1,
      (-2 * mousePosition.y * pixelRatio / canvas.height + 1) / yFactor,
      mousePosition.w
    );

    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.vertexAttribPointer(coordAttribute, 2, gl.FLOAT, false, 0, 0);

    gl.drawArrays(gl.POINTS, 0, HORIZONTAL_SQUARES*VERTICAL_SQUARES);

    theta += dTheta;
    mousePosition.w = (9*mousePosition.w + mousePosition.iw)/10;
    mousePosition.iw *= .98

    if (active)
      requestAnimationFrame(render);
  }

  document.body.addEventListener('mousemove', function(e) {
    var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
    mousePosition.x = e.clientX
    mousePosition.y = e.clientY - canvasOffset + scrollTop
    mousePosition.iw = .6
  })

  var resizeInterval = setInterval(function() {
    // if (canvas && (canvas.offsetWidth != lastSize.width || canvas.offsetHeight != lastSize.height)) {
      resized = true;
      lastSize.width = canvas.offsetWidth
      lastSize.height = canvas.offsetHeight
    // }
  }, 200);

  return { destroy: function() { active = false; clearInterval(resizeInterval); } }
}

var waitFor__selectors = [];
function waitFor(selector, create) {
  waitFor__selectors.push({selector: selector, create: create, exists: false});
}
setInterval(function() {
  waitFor__selectors.forEach(function(spec) {
    var exists = !!document.querySelector(spec.selector)
    if (exists && !spec.exists) spec.background = spec.create(spec.selector)
    if (!exists && spec.exists) spec.background.destroy()
    spec.exists = exists
  })
}, 100)

function fullPageBackground(selector) {
  return (function() {
    var background;
  	document.querySelector('.Main.Main--page iframe').addEventListener('load', function() {
      background = Background(
        document.querySelector('.Main.Main--page'),
        'position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;',
        {
      	  interactionStrength: 2.0,
      	  interactionDistance: 10.0,
      	  noiseStrength: .125,
          scrollRate: 0.02
        })
    })
    return { destroy: function() { if (background) background.destroy() }}
  })()
}
waitFor('#contact-us', fullPageBackground)
waitFor('#jobs-page', fullPageBackground)

function standardBackground(selector) {
  return Background(
    document.querySelector(selector),
    'position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0;')
}
waitFor('#branch-is', standardBackground)
waitFor('#c-fab', standardBackground)
waitFor('#stewardship', standardBackground)
</script>


</body>
</html>
